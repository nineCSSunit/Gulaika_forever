import json
import sys
import asyncio
import logging
from random import choice


from aiogram import Bot, Dispatcher, html, F
from aiogram.client.default import DefaultBotProperties
from aiogram.enums import ParseMode
from aiogram.filters import CommandStart
from aiogram.types import Message
from aiogram.filters import Command
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
from aiogram.types import CallbackQuery
from aiogram.filters import StateFilter


from two_gis_API import search_for_cafe
from browser import get_good_route
from two_gis_API import generate_map_link
from giga_chat_API import general_recognition
from giga_chat_API import place_of_intrerest
from giga_chat_API import prompt_processing
from giga_chat_API import slovarik
from giga_chat_API import interesting_places


#####################################################       –°—á–∏—Ç—ã–≤–∞–Ω–∏–µ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–æ–Ω–Ω–æ–≥–æ —Ñ–∞–π–ª–∞      ####################


with open("config.json") as config_file:
    config = json.load(config_file)

TOKEN = config["TELEGRAM_TOKEN"]

######################################################      –ë–æ—Ç–æ–≤–æ–¥—Å—Ç–≤–æ     ############################################


# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–æ—Ç–∞ –∏ –¥–∏—Å–ø–µ—Ç—á–µ—Ä–∞ —Å –ø–∞–º—è—Ç—å—é —Å–æ—Å—Ç–æ—è–Ω–∏–π
bot = Bot(token=TOKEN)
storage = MemoryStorage()
dp = Dispatcher(storage=storage)


# –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏–π
class PointForm(StatesGroup):
    start_point = State()  # –°–æ—Å—Ç–æ—è–Ω–∏–µ –¥–ª—è –≤–≤–æ–¥–∞ –Ω–∞—á–∞–ª—å–Ω–æ–π —Ç–æ—á–∫–∏
    intermediate_points = State()  # –°–æ—Å—Ç–æ—è–Ω–∏–µ –¥–ª—è –≤–≤–æ–¥–∞ –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã—Ö —Ç–æ—á–µ–∫
    end_point = State()  # –°–æ—Å—Ç–æ—è–Ω–∏–µ –¥–ª—è –≤–≤–æ–¥–∞ –∫–æ–Ω–µ—á–Ω–æ–π —Ç–æ—á–∫–∏


# –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏—è (–º–∞—à–∏–Ω–∞ —Å–æ—Å—Ç–æ—è–Ω–∏–π)
class PromptStates(StatesGroup):
    waiting_for_prompt = State()  # –û–∂–∏–¥–∞–Ω–∏–µ –Ω–∞—á–∞–ª—å–Ω–æ–≥–æ –ø—Ä–æ–º–ø—Ç–∞ –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    waiting_for_start_point = State()  # –û–∂–∏–¥–∞–Ω–∏–µ –Ω–∞—á–∞–ª—å–Ω–æ–π —Ç–æ—á–∫–∏
    waiting_for_end_point = State()  # –û–∂–∏–¥–∞–Ω–∏–µ –∫–æ–Ω–µ—á–Ω–æ–π —Ç–æ—á–∫–∏
    waiting_for_time = State()  # –û–∂–∏–¥–∞–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–∏
    waiting_for_metro = State()  # –û–∂–∏–¥–∞–Ω–∏–µ –±–ª–∏–∂–∞–π—à–µ–≥–æ –º–µ—Ç—Ä–æ
    waiting_for_area = State()  # –û–∂–∏–¥–∞–Ω–∏–µ —Ä–∞–π–æ–Ω–∞
    waiting_for_eat = State()  # –û–∂–∏–¥–∞–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –∫–∞—Ñ–µ
    waiting_for_cafe_choice = State()  # –û–∂–∏–¥–∞–Ω–∏–µ –≤—ã–±–æ—Ä–∞ –∫–∞—Ñ–µ




@dp.message(Command("start"), F.chat.type.in_({"group", "supergroup"}))
async def start_command_in_group(message: Message):
    bot_username = (await bot.get_me()).username
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —É–ø–æ–º—è–Ω—É—Ç –ª–∏ –±–æ—Ç, –µ—Å–ª–∏ –∫–æ–º–∞–Ω–¥–∞ –≤—ã–∑–≤–∞–Ω–∞ –≤ –≥—Ä—É–ø–ø–µ
    if message.text == "/start" or message.text == f"/start@{bot_username}":
        await message.reply("–ë–æ—Ç –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω –≤ –≥—Ä—É–ø–ø–µ!")



# –•–µ–Ω–¥–ª–µ—Ä –Ω–∞ –∫–æ–º–∞–Ω–¥—É /prompt
@dp.message(Command('prompt'))
async def handle_prompt_command(message: Message, state: FSMContext):
    await message.answer("–í–≤–µ–¥–∏—Ç–µ —Å–≤–æ–π –ø—Ä–æ–º–ø—Ç:")
    await state.set_state(PromptStates.waiting_for_prompt)


# –•–µ–Ω–¥–ª–µ—Ä –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –≤–≤–µ–¥–µ–Ω–Ω–æ–≥–æ –ø—Ä–æ–º–ø—Ç–∞
@dp.message(PromptStates.waiting_for_prompt)
async def handle_prompt_input(message: Message, state: FSMContext):
    prompt_text = message.text  # –ü–æ–ª—É—á–∞–µ–º –≤–≤–µ–¥–µ–Ω–Ω—ã–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º —Ç–µ–∫—Å—Ç
    await message.answer(f"–í–∞—à –ø—Ä–æ–º–ø—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω: {prompt_text}")

    # –í—ã–ø–æ–ª–Ω—è–µ–º –ø–µ—Ä–≤–∏—á–Ω—É—é –æ–±—Ä–∞–±–æ—Ç–∫—É —Ç–µ–∫—Å—Ç–∞
    d = prompt_processing(prompt_text, "base", "base")
    await message.answer(d)

    # –û–±—Ä–∞–±–æ—Ç–∫–∞ –∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Å–ª–æ–≤–∞—Ä—è
    d = slovarik(d)
    await state.update_data(prompt_data=d)

    # –ó–∞–ø—Ä–∞—à–∏–≤–∞–µ–º —Å–ª–µ–¥—É—é—â—É—é –Ω–µ–¥–æ—Å—Ç–∞—é—â—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é, –µ—Å–ª–∏ –æ–Ω–∞ –µ—Å—Ç—å
    await request_next_info(d, message, state)


# –§—É–Ω–∫—Ü–∏—è –∑–∞–ø—Ä–æ—Å–∞ —Å–ª–µ–¥—É—é—â–µ–π –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏
async def request_next_info(data, message: Message, state: FSMContext):
    prompts = {
        '–Ω–∞—á–∞–ª—å–Ω–∞—è —Ç–æ—á–∫–∞': (PromptStates.waiting_for_start_point, "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ –Ω–∞—á–∞–ª—å–Ω—É—é —Ç–æ—á–∫—É."),
        '–∫–æ–Ω–µ—á–Ω–∞—è —Ç–æ—á–∫–∞': (PromptStates.waiting_for_end_point, "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ –∫–æ–Ω–µ—á–Ω—É—é —Ç–æ—á–∫—É."),
        '–≥–¥–µ –ø–æ–µ—Å—Ç—å': (PromptStates.waiting_for_eat, "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ, –≥–¥–µ –±—ã —Ö–æ—Ç–µ–ª–∏ –ø–æ–µ—Å—Ç—å."),
        '–≤—Ä–µ–º—è': (PromptStates.waiting_for_time, "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ –≤—Ä–µ–º—è."),
        '–º–µ—Ç—Ä–æ': (PromptStates.waiting_for_metro, "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ –±–ª–∏–∂–∞–π—à–µ–µ –º–µ—Ç—Ä–æ."),
        '—Ä–∞–π–æ–Ω': (PromptStates.waiting_for_area, "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ —Ä–∞–π–æ–Ω.")
    }

    # –ó–∞–≥—Ä—É–∂–∞–µ–º —Ñ—Ä–∞–∑—ã –∏–∑ JSON-—Ñ–∞–π–ª–∞
    def load_phrases(file_path="phrases.json"):
        with open(file_path, "r", encoding="utf-8") as file:
            return json.load(file)

    # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–ª–æ–≤–∞—Ä—è prompts —Å–ª—É—á–∞–π–Ω–æ–π —Ñ—Ä–∞–∑–æ–π
    def update_prompts(phrases):
        for key1 in prompts:
            state, _ = prompts[key1]  # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
            random_phrase = choice(phrases[key1])  # –ë–µ—Ä—ë–º —Å–ª—É—á–∞–π–Ω—É—é —Ñ—Ä–∞–∑—É –∏–∑ JSON
            prompts[key1] = (state, random_phrase)  # –û–±–Ω–æ–≤–ª—è–µ–º –∑–Ω–∞—á–µ–Ω–∏–µ

    # –ó–∞–≥—Ä—É–∑–∫–∞ —Ñ—Ä–∞–∑ –∏–∑ JSON –∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ prompts
    phrases = load_phrases()
    update_prompts(phrases)

    # –¢–µ–ø–µ—Ä—å prompts —Å–æ–¥–µ—Ä–∂–∏—Ç —Å–ª—É—á–∞–π–Ω—ã–µ —Ñ—Ä–∞–∑—ã
    print(prompts)


    for key, (next_state, prompt_message) in prompts.items():
        if data.get(key) == '–Ω–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏':
            await message.answer(prompt_message)
            await state.set_state(next_state)
            return

    # –ï—Å–ª–∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –∫–∞—Ñ–µ —É–∂–µ –µ—Å—Ç—å, –ø—Ä–µ–¥–ª–æ–∂–∏–º –≤—ã–±–æ—Ä –∫–∞—Ñ–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
    if '–≥–¥–µ –ø–æ–µ—Å—Ç—å' in data and data['–≥–¥–µ –ø–æ–µ—Å—Ç—å'] != '–Ω–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏':
        await offer_cafes(message, state)
    else:
        await finish_process(message, state)


# –§—É–Ω–∫—Ü–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ —Å –æ–±—Ä–∞–±–æ—Ç–∫–æ–π `prompt_processing`
async def handle_info_update(message: Message, state: FSMContext, key: str):
    # –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –¥–ª—è `prompt_processing` –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –∫–ª—é—á–∞
    processing_params = {
        '–Ω–∞—á–∞–ª—å–Ω–∞—è —Ç–æ—á–∫–∞': ("additional", "start"),
        '–∫–æ–Ω–µ—á–Ω–∞—è —Ç–æ—á–∫–∞': ("additional", "end"),
        '–≥–¥–µ –ø–æ–µ—Å—Ç—å': ("additional", "cafe"),
        '–≤—Ä–µ–º—è': ("additional", "time"),
        '–º–µ—Ç—Ä–æ': ("additional", "metro"),
        '—Ä–∞–π–æ–Ω': ("additional", "area")
    }

    # –ü–æ–ª—É—á–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –¥–ª—è –≤—ã–∑–æ–≤–∞ `prompt_processing`
    mode, detail = processing_params.get(key, ("additional", "default"))

    # –í—ã–ø–æ–ª–Ω—è–µ–º –æ–±—Ä–∞–±–æ—Ç–∫—É —Ç–µ–∫—Å—Ç–∞ —Å —É–∫–∞–∑–∞–Ω–Ω—ã–º–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏
    processed_data = prompt_processing(message.text, mode, detail)

    # –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–∏–µ –¥–∞–Ω–Ω—ã–µ –∏–∑ —Å–æ—Å—Ç–æ—è–Ω–∏—è –∏ –æ–±–Ω–æ–≤–ª—è–µ–º –∏—Ö
    user_data = await state.get_data()
    prompt_data = user_data['prompt_data']
    prompt_data[key] = processed_data
    await state.update_data(prompt_data=prompt_data)

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω—É–∂–Ω–æ –ª–∏ –∑–∞–ø—Ä–æ—Å–∏—Ç—å –µ—â–µ —á—Ç–æ-—Ç–æ
    await request_next_info(prompt_data, message, state)


# –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è –∫–∞—Ñ–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
async def offer_cafes(message: Message, state: FSMContext):
    user_data = await state.get_data()
    prompt_data = user_data['prompt_data']
    cafe_type = prompt_data['–≥–¥–µ –ø–æ–µ—Å—Ç—å']  # –ü–æ–ª—É—á–∞–µ–º —Ç–∏–ø –∫–∞—Ñ–µ, –≤—ã–±—Ä–∞–Ω–Ω—ã–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º
    points = prompt_data['–º–µ—Å—Ç–æ'].split(', ')
    print(points)

    # –ü–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ –∫–∞—Ñ–µ –≤–æ–∫—Ä—É–≥ –∑–∞–¥–∞–Ω–Ω–æ–π —Ç–æ—á–∫–∏
    cafes = search_for_cafe(cafe_type, points)
    await state.update_data(cached_cafes=cafes)

    # –ü—Ä–æ–≤–µ—Ä–∫–∞, –µ—Å–ª–∏ –∫–∞—Ñ–µ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã
    if not cafes:
        await message.answer("–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ –∫–∞—Ñ–µ –ø–æ –≤–∞—à–µ–º—É –∑–∞–ø—Ä–æ—Å—É.")
        await finish_process(message, state)
        return

    # –§–æ—Ä–º–∏—Ä—É–µ–º –æ–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –∫–∞—Ñ–µ –∏ —Å–æ–∑–¥–∞–µ–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É
    inline_keyboard = []

    for cafe in cafes:
        # –§–æ—Ä–º–∏—Ä—É–µ–º –æ–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –∫–∞—Ñ–µ
        reviews_text = (
            f"–û—Ç–∑—ã–≤—ã: {cafe['reviews']['general_review_count']} "
            f"(—Ä–µ–π—Ç–∏–Ω–≥: {cafe['reviews']['general_rating']})"
        )
        cafe_info = (
            f"üè† {cafe['name']}\n"
            f"üìç –ê–¥—Ä–µ—Å: {cafe['address_name']}\n"
            f"‚≠ê {reviews_text}\n"
            "–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ñ–µ, –Ω–∞–∂–∞–≤ –Ω–∞ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â—É—é –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ."
        )

        # –°–æ–∑–¥–∞–µ–º –∫–Ω–æ–ø–∫—É –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –∫–∞—Ñ–µ
        cafe_button = InlineKeyboardButton(
            text=f"{cafe['name']} - {cafe['reviews']['general_rating']}‚≠ê",
            callback_data=f"choose_cafe:{cafe['id']}"
        )
        # –î–æ–±–∞–≤–ª—è–µ–º –∫–Ω–æ–ø–∫—É –≤ —Å—Ç—Ä–æ–∫—É –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã
        inline_keyboard.append([cafe_button])

        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∫–∞—Ñ–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
        await message.answer(cafe_info)

    # –°–æ–∑–¥–∞–µ–º –æ–±—ä–µ–∫—Ç –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã
    keyboard = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)

    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É –≤ –ø–æ—Å–ª–µ–¥–Ω–µ–º —Å–æ–æ–±—â–µ–Ω–∏–∏
    await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ñ–µ:", reply_markup=keyboard)

    # –ü–µ—Ä–µ–≤–æ–¥–∏–º –±–æ—Ç–∞ –≤ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –æ–∂–∏–¥–∞–Ω–∏—è –≤—ã–±–æ—Ä–∞ –∫–∞—Ñ–µ
    await state.set_state(PromptStates.waiting_for_cafe_choice)


# –•–µ–Ω–¥–ª–µ—Ä –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –≤—ã–±–æ—Ä–∞ –∫–∞—Ñ–µ
@dp.callback_query(StateFilter(PromptStates.waiting_for_cafe_choice), lambda c: c.data.startswith('choose_cafe'))
async def handle_cafe_choice(callback_query: CallbackQuery, state: FSMContext):
    cafe_id = callback_query.data.split(':')[1]
    user_data = await state.get_data()
    prompt_data = user_data['prompt_data']
    print(prompt_data)
    # –ù–∞—Ö–æ–¥–∏–º –≤—ã–±—Ä–∞–Ω–Ω–æ–µ –∫–∞—Ñ–µ –ø–æ id –∏ –¥–æ–±–∞–≤–ª—è–µ–º –µ–≥–æ –Ω–∞–∑–≤–∞–Ω–∏–µ –≤ "–º–µ—Å—Ç–∞"
    cafes = user_data['cached_cafes']
    print(cafes)
    selected_cafe = next((cafe for cafe in cafes if cafe['id'] == cafe_id), None)
    print(selected_cafe)

    if selected_cafe:
        # –î–æ–±–∞–≤–ª—è–µ–º –≤—ã–±—Ä–∞–Ω–Ω–æ–µ –∫–∞—Ñ–µ –≤ —Å–ø–∏—Å–æ–∫ "–º–µ—Å—Ç–∞"
        if '–º–µ—Å—Ç–æ' in prompt_data:
            prompt_data['–º–µ—Å—Ç–æ'] += f", {selected_cafe['name'].replace(",", "")}"
        else:
            prompt_data['–º–µ—Å—Ç–æ'] = selected_cafe['name']
            print(prompt_data)
        await state.update_data(prompt_data=prompt_data)

        # –°–æ–æ–±—â–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é –æ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –∫–∞—Ñ–µ
        await callback_query.message.answer(f"–í—ã –≤—ã–±—Ä–∞–ª–∏ –∫–∞—Ñ–µ: {selected_cafe['name']}. –û–Ω–æ –¥–æ–±–∞–≤–ª–µ–Ω–æ –≤ –º–∞—Ä—à—Ä—É—Ç.")

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –µ—â–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è, –∫–æ—Ç–æ—Ä—É—é –Ω—É–∂–Ω–æ –∑–∞–ø—Ä–æ—Å–∏—Ç—å
        if '–∫–æ–Ω–µ—á–Ω–∞—è —Ç–æ—á–∫–∞' in prompt_data and '–Ω–∞—á–∞–ª—å–Ω–∞—è —Ç–æ—á–∫–∞' in prompt_data:
            await finish_process(callback_query.message, state)
        else:
            await request_next_info(prompt_data, callback_query.message, state)


# –ò—Å–ø–æ–ª—å–∑—É–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ `handle_info_update` –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è
@dp.message(PromptStates.waiting_for_start_point)
async def handle_start_point(message: Message, state: FSMContext):
    await handle_info_update(message, state, '–Ω–∞—á–∞–ª—å–Ω–∞—è —Ç–æ—á–∫–∞')


@dp.message(PromptStates.waiting_for_end_point)
async def handle_end_point(message: Message, state: FSMContext):
    await handle_info_update(message, state, '–∫–æ–Ω–µ—á–Ω–∞—è —Ç–æ—á–∫–∞')


@dp.message(PromptStates.waiting_for_time)
async def handle_time(message: Message, state: FSMContext):
    await handle_info_update(message, state, '–≤—Ä–µ–º—è')


@dp.message(PromptStates.waiting_for_metro)
async def handle_metro(message: Message, state: FSMContext):
    await handle_info_update(message, state, '–º–µ—Ç—Ä–æ')


@dp.message(PromptStates.waiting_for_area)
async def handle_area(message: Message, state: FSMContext):
    await handle_info_update(message, state, '—Ä–∞–π–æ–Ω')


@dp.message(PromptStates.waiting_for_eat)
async def handle_eat(message: Message, state: FSMContext):
    await handle_info_update(message, state, '–≥–¥–µ –ø–æ–µ—Å—Ç—å')


# –§–∏–Ω–∞–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –ø—Ä–æ—Ü–µ—Å—Å–∞
async def finish_process(message: Message, state: FSMContext):
    user_data = await state.get_data()
    prompt_data = user_data['prompt_data']

    await message.answer(f"–°–ø–∞—Å–∏–±–æ! –í–æ—Ç –æ–∫–æ–Ω—á–∞—Ç–µ–ª—å–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è:\n{prompt_data}")
    await message.answer("–í–æ—Ç –≤–∞—à –º–∞—Ä—à—Ä—É—Ç: ")

    start_point = prompt_data['–Ω–∞—á–∞–ª—å–Ω–∞—è —Ç–æ—á–∫–∞']
    intermediate_points = prompt_data.get('–º–µ—Å—Ç–æ', "").split(', ')
    end_point = prompt_data['–∫–æ–Ω–µ—á–Ω–∞—è —Ç–æ—á–∫–∞']

    points = (
            [f"–ù–∞—á–∞–ª—å–Ω–∞—è: {start_point}"]
            + [f"–ü—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω–∞—è: {point}" for point in intermediate_points]
            + [f"–ö–æ–Ω–µ—á–Ω–∞—è: {end_point}"]
    )

    await message.answer("\n".join(points))

    link = get_good_route(generate_map_link([start_point] + intermediate_points + [end_point]))
    print(link)
    await message.answer(link)

    await state.clear()


@dp.message(Command("route_prompt"))
async def aboba(message: Message, state: FSMContext):
    await message.answer("–í–æ—Ç –≤–∞—à –º–∞—Ä—à—Ä—É—Ç: ")
    # –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ –¥–∞–Ω–Ω—ã–µ
    data = await state.get_data()
    start_point = data.get('–Ω–∞—á–∞–ª—å–Ω–∞—è —Ç–æ—á–∫–∞')
    intermediate_points = data.get('–º–µ—Å—Ç–æ', [])
    end_point = data.get('–∫–æ–Ω–µ—á–Ω–∞—è —Ç–æ—á–∫–∞')

    # –§–æ—Ä–º–∏—Ä—É–µ–º –∏ –≤—ã–≤–æ–¥–∏–º —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö —Ç–æ—á–µ–∫
    points = (
            [f"–ù–∞—á–∞–ª—å–Ω–∞—è: {start_point}"]
            + [f"–ü—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω–∞—è: {point}" for point in intermediate_points]
            + [f"–ö–æ–Ω–µ—á–Ω–∞—è: {end_point}"]
    )

    await message.answer("\n".join(points))

    points = [start_point] + intermediate_points + [end_point]
    link = get_good_route(generate_map_link(points))

    await message.answer(link)




@dp.message(Command("get_route"))
async def start(message: Message, state: FSMContext):
    await message.answer("–í–≤–µ–¥–∏—Ç–µ –Ω–∞—á–∞–ª—å–Ω—É—é —Ç–æ—á–∫—É:")
    await state.set_state(PointForm.start_point)


# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –≤–≤–æ–¥–∞ –Ω–∞—á–∞–ª—å–Ω–æ–π —Ç–æ—á–∫–∏
@dp.message(PointForm.start_point)
async def enter_start_point(message: Message, state: FSMContext):
    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –Ω–∞—á–∞–ª—å–Ω—É—é —Ç–æ—á–∫—É
    await state.update_data(start_point=message.text)

    # –°–ø—Ä–∞—à–∏–≤–∞–µ–º –ø—Ä–æ –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã–µ —Ç–æ—á–∫–∏
    await message.answer(
        "–í–≤–µ–¥–∏—Ç–µ –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã–µ —Ç–æ—á–∫–∏ (–ø–æ –æ–¥–Ω–æ–π –∑–∞ —Ä–∞–∑). –ö–æ–≥–¥–∞ –∑–∞–∫–æ–Ω—á–∏—Ç–µ, –Ω–∞–ø–∏—à–∏—Ç–µ '–°—Ç–æ–ø'."
    )
    await state.set_state(PointForm.intermediate_points)


# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –≤–≤–æ–¥–∞ –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã—Ö —Ç–æ—á–µ–∫
@dp.message(PointForm.intermediate_points, F.text.lower() != "—Å—Ç–æ–ø")
async def enter_intermediate_points(message: Message, state: FSMContext):
    data = await state.get_data()

    # –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—É—é –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—É—é —Ç–æ—á–∫—É –≤ —Å–ø–∏—Å–æ–∫
    intermediate_points = data.get("intermediate_points", [])
    intermediate_points.append(message.text)
    await state.update_data(intermediate_points=intermediate_points)

    # –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º –¥–∏–∞–ª–æ–≥
    await message.answer(
        "–í–≤–µ–¥–∏—Ç–µ –µ—â—ë –æ–¥–Ω—É –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—É—é —Ç–æ—á–∫—É –∏–ª–∏ –Ω–∞–ø–∏—à–∏—Ç–µ '–°—Ç–æ–ø' –¥–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è."
    )


# –û–±—Ä–∞–±–æ—Ç—á–∏–∫, –∫–æ–≥–¥–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤–≤–æ–¥–∏—Ç "–°—Ç–æ–ø"
@dp.message(PointForm.intermediate_points, F.text.lower() == "—Å—Ç–æ–ø")
async def stop_intermediate_points(message: Message, state: FSMContext):
    # –°–ø—Ä–∞—à–∏–≤–∞–µ–º –ø—Ä–æ –∫–æ–Ω–µ—á–Ω—É—é —Ç–æ—á–∫—É
    await message.answer("–í–≤–µ–¥–∏—Ç–µ –∫–æ–Ω–µ—á–Ω—É—é —Ç–æ—á–∫—É:")
    await state.set_state(PointForm.end_point)


# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –≤–≤–æ–¥–∞ –∫–æ–Ω–µ—á–Ω–æ–π —Ç–æ—á–∫–∏ –∏ –≤—ã–≤–æ–¥–∞ –º–∞—Ä—à—Ä—É—Ç–∞
@dp.message(PointForm.end_point)
async def enter_end_point(message: Message, state: FSMContext):
    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∫–æ–Ω–µ—á–Ω—É—é —Ç–æ—á–∫—É
    await state.update_data(end_point=message.text)

    # –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ –¥–∞–Ω–Ω—ã–µ
    data = await state.get_data()
    start_point = data.get("start_point")
    intermediate_points = data.get("intermediate_points", [])
    end_point = data.get("end_point")

    # –§–æ—Ä–º–∏—Ä—É–µ–º –∏ –≤—ã–≤–æ–¥–∏–º —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö —Ç–æ—á–µ–∫
    points = (
        [f"–ù–∞—á–∞–ª—å–Ω–∞—è: {start_point}"]
        + [f"–ü—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω–∞—è: {point}" for point in intermediate_points]
        + [f"–ö–æ–Ω–µ—á–Ω–∞—è: {end_point}"]
    )

    await message.answer("\n".join(points))

    points = [start_point] + intermediate_points + [end_point]
    link = get_good_route(generate_map_link(points))

    await message.answer(link)
    intermediate_points = None
    # –ó–∞–∫–∞–Ω—á–∏–≤–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
    await state.clear()

"""
@dp.message(CommandStart())
async def command_start_handler(message: Message) -> None:
    await message.answer(f"Hello, {html.bold(message.from_user.full_name)}!")
"""

async def main() -> None:
    # Initialize Bot instance with default bot properties which will be passed to all API calls
    bot = Bot(token=TOKEN, default=DefaultBotProperties(parse_mode=ParseMode.HTML))

    # And the run events dispatching
    await dp.start_polling(bot)




if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO, stream=sys.stdout)
    asyncio.run(main())
